{"ast":null,"code":"import _toConsumableArray from \"E:/IOT_PROJECT-Dev_LgBao/Frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"E:/IOT_PROJECT-Dev_LgBao/Frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React, { createContext, useState, useRef, useEffect, useContext } from 'react';\nimport SockJS from 'sockjs-client';\nimport { Client } from '@stomp/stompjs';\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nvar StompContext = createContext(undefined);\nvar _excluded = [\"url\", \"children\", \"stompClientOptions\"];\n/**\r\n * The StompSessionProvider manages the STOMP connection\r\n * All Hooks and HOCs in this library require an ancestor of this type.\r\n * The URL to connect to can be specified via the url prop.\r\n * Depending on the Schema of the URL either Sockjs or a raw Websocket is used.\r\n * You can override this behavior with the brokerURL or webSocketFactory props, which will then be forwarded to @stomp/stompjs\r\n * Custom @stomp/stompjs options can be used as props.\r\n * Please consult the @stomp/stompjs documentation for more information.\r\n */\n\nfunction StompSessionProvider(props) {\n  var url = props.url,\n    children = props.children,\n    stompClientOptions = props.stompClientOptions,\n    stompOptions = _objectWithoutPropertiesLoose(props, _excluded); // Support old API\n\n  if (stompClientOptions) stompOptions = stompClientOptions;\n  var _useState = useState(undefined),\n    _useState2 = _slicedToArray(_useState, 2),\n    client = _useState2[0],\n    setClient = _useState2[1];\n  var subscriptionRequests = useRef(new Map());\n  useEffect(function () {\n    var _client = new Client(stompOptions);\n    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {\n      _client.webSocketFactory = function () {\n        var _window, _window$location;\n        var parsedUrl = new URL(url, (_window = window) == null ? void 0 : (_window$location = _window.location) == null ? void 0 : _window$location.href);\n        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {\n          return new SockJS(url);\n        } else if (parsedUrl.protocol === 'ws:' || parsedUrl.protocol === 'wss:') {\n          return new WebSocket(url);\n        } else throw new Error('Protocol not supported');\n      };\n    }\n    _client.onConnect = function (frame) {\n      if (stompOptions.onConnect) stompOptions.onConnect(frame);\n      subscriptionRequests.current.forEach(function (value) {\n        value.subscription = _client.subscribe(value.destination, value.callback, value.headers);\n      });\n      setClient(_client);\n    };\n    _client.onWebSocketClose = function (event) {\n      if (stompOptions.onWebSocketClose) stompOptions.onWebSocketClose(event);\n      setClient(undefined);\n    };\n    if (!stompOptions.onStompError) {\n      _client.onStompError = function (frame) {\n        throw frame;\n      };\n    }\n    _client.activate();\n    return function () {\n      _client.deactivate();\n    };\n  }, [url].concat(_toConsumableArray(Object.values(stompOptions))));\n  var subscribe = function subscribe(destination, callback) {\n    var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var subscriptionId = Math.random().toString(36).substr(2, 9);\n    var subscriptionRequest = {\n      destination: destination,\n      callback: callback,\n      headers: headers\n    };\n    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);\n    if (client && client.connected) {\n      subscriptionRequest.subscription = client.subscribe(destination, callback, headers);\n    }\n    return function () {\n      var subscriptionData = subscriptionRequests.current.get(subscriptionId);\n      if (subscriptionData.subscription) {\n        subscriptionData.subscription.unsubscribe();\n      }\n      subscriptionRequests.current.delete(subscriptionId);\n    };\n  };\n  return React.createElement(StompContext.Provider, {\n    value: {\n      client: client,\n      subscribe: subscribe\n    }\n  }, children);\n}\n\n/**\r\n *\r\n * @param destinations The destinations to subscribe to. Can be a string for a single destination or an array of strings for multiple.\r\n * @param onMessage Callback called when a message arrives for this subscription\r\n * @param headers Additional Headers for this subscription, consult @stomp/stompjs docs.\r\n */\n\nfunction useSubscription(destinations, onMessage) {\n  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var stompContext = useContext(StompContext);\n  if (stompContext === undefined) throw new Error('There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs');\n  var callbackRef = useRef(onMessage);\n  var _destinations = Array.isArray(destinations) ? destinations : [destinations];\n  callbackRef.current = onMessage;\n  useEffect(function () {\n    var cleanUpFunctions = [];\n    _destinations.forEach(function (_destination) {\n      return cleanUpFunctions.push(stompContext.subscribe(_destination, function (message) {\n        callbackRef.current(message);\n      }, headers));\n    });\n    return function () {\n      cleanUpFunctions.forEach(function (_cleanUpFunction) {\n        _cleanUpFunction();\n      });\n    };\n  }, [Object.values(_destinations).toString(), Object.values(headers).toString()]);\n}\n\n/**\r\n * Returns the Stomp Client from @stomp/stompjs\r\n * This will be undefined if the client is currently not connected\r\n */\n\nfunction useStompClient() {\n  var context = useContext(StompContext);\n  if (context === undefined) throw new Error('There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs');\n  return context.client;\n}\nfunction withStompClient(WrappedComponent) {\n  return function (props) {\n    var stompClient = useStompClient();\n    return React.createElement(WrappedComponent, Object.assign({\n      stompClient: stompClient\n    }, props));\n  };\n}\nfunction withSubscription(WrappedComponent, destinations) {\n  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return function (props) {\n    var ref = useRef();\n    useSubscription(destinations, function (message) {\n      if (ref.current) ref.current.onMessage(message);\n    }, headers); // @ts-ignore\n\n    return React.createElement(WrappedComponent, Object.assign({\n      ref: ref\n    }, props));\n  };\n}\nvar subscriptions = new Map();\nfunction subscribeMock(destination, callback) {\n  var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var subscriptionId = Math.random().toString(36).substr(2, 9);\n  if (!subscriptions.has(destination)) {\n    subscriptions.set(destination, new Map());\n  } // @ts-ignore\n\n  subscriptions.get(destination).set(subscriptionId, callback);\n  return function () {\n    // @ts-ignore\n    subscriptions.get(destination).delete(subscriptionId);\n  };\n}\n/**\r\n * Simulates receiving a message from the server to the specified destination\r\n * @param destination The topic to send the message to\r\n * @param message The message to send\r\n */\n\nfunction mockReceiveMessage(destination, message) {\n  if (subscriptions.has(destination)) {\n    // @ts-ignore\n    subscriptions.get(destination).forEach(function (callback) {\n      callback(message);\n    });\n  }\n}\n/**\r\n * Gets the current subscriptions for the specified destination\r\n * @param destination The topic to get the subscriptions for, or undefined to get all subscriptions\r\n */\n\nfunction getMockSubscriptions(destination) {\n  if (destination) {\n    return subscriptions.get(destination);\n  }\n  return subscriptions;\n}\nvar messages = new Map();\n/**\r\n * A mock implementation of the publish function of the @stomp/stompjs client.\r\n * Will store the messages in a map, keyed by the destination.\r\n * @param params\r\n */\n\nfunction mockClientPublish(params) {\n  if (!messages.has(params.destination)) {\n    messages.set(params.destination, []);\n  } // @ts-ignore\n\n  messages.get(params.destination).push(params);\n}\n/**\r\n * Gets a default Mock of the @stomp/stompjs client.\r\n * If you require a custom client, you can use this as a base.\r\n */\n\nfunction getMockClient() {\n  return {\n    publish: mockClientPublish\n  };\n}\n/**\r\n * Gets all messages which have been sent via a mock client.\r\n * @param destination The destination to get messages for, or undefined to get all messages.\r\n */\n\nfunction getSentMockMessages(destination) {\n  if (destination) {\n    return messages.get(destination);\n  }\n  return messages;\n}\n\n/**\r\n * A mock StompSessionProvider.\r\n * Messages send via this mock implementation can be received via the getSentMockMessages method.\r\n * Subscriptions can be received via the getMockSubscriptions method.\r\n * The sendMockMessage method can be used, to simulate receiving a message from the server.\r\n *\r\n * @param props.client Optional. Can be used to provide a custom mock of the sompjs client,\r\n * in case you require additional properties/functions to be present. getMockClient can be used as a base.\r\n * @constructor\r\n */\n\nfunction StompSessionProviderMock(props) {\n  var _props$client;\n  return React.createElement(StompContext.Provider, {\n    value: {\n      subscribe: subscribeMock,\n      // @ts-ignore\n      client: (_props$client = props.client) != null ? _props$client : getMockClient()\n    }\n  }, props.children);\n}\n\n/**\r\n * Resets the state of the mock implementation, clearing all subscriptions and messages.\r\n */\n\nfunction reset() {\n  subscriptions.clear();\n  messages.clear();\n}\nvar index = {\n  __proto__: null,\n  StompSessionProviderMock: StompSessionProviderMock,\n  getMockClient: getMockClient,\n  mockClientPublish: mockClientPublish,\n  mockReceiveMessage: mockReceiveMessage,\n  getSentMockMessages: getSentMockMessages,\n  reset: reset,\n  getMockSubscriptions: getMockSubscriptions\n};\nexport { StompSessionProvider, index as mock, useStompClient, useSubscription, withStompClient, withSubscription };","map":{"version":3,"names":["StompContext","createContext","undefined","StompSessionProvider","props","url","children","stompClientOptions","stompOptions","_objectWithoutPropertiesLoose","_excluded","_useState","useState","_useState2","_slicedToArray","client","setClient","subscriptionRequests","useRef","Map","useEffect","_client","Client","brokerURL","webSocketFactory","_window","_window$location","parsedUrl","URL","window","location","href","protocol","SockJS","WebSocket","Error","onConnect","frame","current","forEach","value","subscription","subscribe","destination","callback","headers","onWebSocketClose","event","onStompError","activate","deactivate","concat","_toConsumableArray","Object","values","arguments","length","subscriptionId","Math","random","toString","substr","subscriptionRequest","set","connected","subscriptionData","get","unsubscribe","delete","React","createElement","Provider","useSubscription","destinations","onMessage","stompContext","useContext","callbackRef","_destinations","Array","isArray","cleanUpFunctions","_destination","push","message","_cleanUpFunction","useStompClient","context","withStompClient","WrappedComponent","stompClient","assign","withSubscription","ref","subscriptions","subscribeMock","has","mockReceiveMessage","getMockSubscriptions","messages","mockClientPublish","params","getMockClient","publish","getSentMockMessages","StompSessionProviderMock","_props$client","reset","clear"],"sources":["E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\context\\StompContext.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\components\\StompSessionProvider.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\hooks\\useSubscription.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\hooks\\useStompClient.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\hoc\\withStompClient.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\hoc\\withSubscription.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\mock\\subscriptions.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\mock\\client.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\mock\\StompSessionProviderMock.tsx","E:\\IOT_PROJECT-Dev_LgBao\\Frontend\\node_modules\\react-stomp-hooks\\src\\mock\\reset.tsx"],"sourcesContent":["import { createContext } from 'react';\nimport { StompSessionProviderContext } from '../interfaces/StompSessionProviderContext';\n\nconst StompContext = createContext<StompSessionProviderContext | undefined>(\n  undefined\n);\n\nexport default StompContext;\n","import React, { useEffect, useRef, useState } from 'react';\nimport StompContext from '../context/StompContext';\nimport SockJS from 'sockjs-client';\nimport {\n  Client,\n  IStompSocket,\n  messageCallbackType,\n  StompHeaders\n} from '@stomp/stompjs';\nimport { StompSessionProviderProps } from '../interfaces/StompSessionProviderProps';\nimport { StompSessionSubscription } from '../interfaces/StompSessionSubscription';\n\n/**\n * The StompSessionProvider manages the STOMP connection\n * All Hooks and HOCs in this library require an ancestor of this type.\n * The URL to connect to can be specified via the url prop.\n * Depending on the Schema of the URL either Sockjs or a raw Websocket is used.\n * You can override this behavior with the brokerURL or webSocketFactory props, which will then be forwarded to @stomp/stompjs\n * Custom @stomp/stompjs options can be used as props.\n * Please consult the @stomp/stompjs documentation for more information.\n */\nfunction StompSessionProvider(props: StompSessionProviderProps) {\n  let { url, children, stompClientOptions, ...stompOptions } = props;\n\n  // Support old API\n  if (stompClientOptions) stompOptions = stompClientOptions;\n\n  const [client, setClient] = useState<Client | undefined>(undefined);\n  const subscriptionRequests = useRef(new Map());\n\n  useEffect(() => {\n    const _client = new Client(stompOptions);\n\n    if (!stompOptions.brokerURL && !stompOptions.webSocketFactory) {\n      _client.webSocketFactory = function () {\n        const parsedUrl = new URL(url, window?.location?.href);\n        if (parsedUrl.protocol === 'http:' || parsedUrl.protocol === 'https:') {\n          return new SockJS(url) as IStompSocket;\n        } else if (\n          parsedUrl.protocol === 'ws:' ||\n          parsedUrl.protocol === 'wss:'\n        ) {\n          return new WebSocket(url) as IStompSocket;\n        } else throw new Error('Protocol not supported');\n      };\n    }\n\n    _client.onConnect = function (frame) {\n      if (stompOptions.onConnect) stompOptions.onConnect(frame);\n\n      subscriptionRequests.current.forEach((value) => {\n        value.subscription = _client.subscribe(\n          value.destination,\n          value.callback,\n          value.headers\n        );\n      });\n\n      setClient(_client);\n    };\n\n    _client.onWebSocketClose = function (event) {\n      if (stompOptions.onWebSocketClose) stompOptions.onWebSocketClose(event);\n\n      setClient(undefined);\n    };\n\n    if (!stompOptions.onStompError) {\n      _client.onStompError = function (frame) {\n        throw frame;\n      };\n    }\n\n    _client.activate();\n\n    return () => {\n      _client.deactivate();\n    };\n  }, [url, ...Object.values(stompOptions)]);\n\n  const subscribe = (\n    destination: string,\n    callback: messageCallbackType,\n    headers: StompHeaders = {}\n  ) => {\n    const subscriptionId = Math.random().toString(36).substr(2, 9);\n    const subscriptionRequest: StompSessionSubscription = {\n      destination,\n      callback,\n      headers\n    };\n\n    subscriptionRequests.current.set(subscriptionId, subscriptionRequest);\n\n    if (client && client.connected) {\n      subscriptionRequest.subscription = client.subscribe(\n        destination,\n        callback,\n        headers\n      );\n    }\n\n    return () => {\n      const subscriptionData = subscriptionRequests.current.get(subscriptionId);\n\n      if (subscriptionData.subscription) {\n        subscriptionData.subscription.unsubscribe();\n      }\n\n      subscriptionRequests.current.delete(subscriptionId);\n    };\n  };\n\n  return (\n    <StompContext.Provider\n      value={{\n        client,\n        subscribe\n      }}\n    >\n      {children}\n    </StompContext.Provider>\n  );\n}\n\nexport default StompSessionProvider;\n","import { useContext, useEffect, useRef } from 'react';\nimport StompContext from '../context/StompContext';\nimport { messageCallbackType, StompHeaders } from '@stomp/stompjs';\n\n/**\n *\n * @param destinations The destinations to subscribe to. Can be a string for a single destination or an array of strings for multiple.\n * @param onMessage Callback called when a message arrives for this subscription\n * @param headers Additional Headers for this subscription, consult @stomp/stompjs docs.\n */\nfunction useSubscription(\n  destinations: string | string[],\n  onMessage: messageCallbackType,\n  headers: StompHeaders = {}\n) {\n  const stompContext = useContext(StompContext);\n\n  if (stompContext === undefined)\n    throw new Error(\n      'There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs'\n    );\n\n  const callbackRef = useRef<messageCallbackType>(onMessage);\n  const _destinations = Array.isArray(destinations)\n    ? destinations\n    : [destinations];\n\n  callbackRef.current = onMessage;\n\n  useEffect(() => {\n    const cleanUpFunctions: (() => void)[] = [];\n\n    _destinations.forEach((_destination) =>\n      cleanUpFunctions.push(\n        stompContext.subscribe(\n          _destination,\n          (message) => {\n            callbackRef.current(message);\n          },\n          headers\n        )\n      )\n    );\n\n    return () => {\n      cleanUpFunctions.forEach((_cleanUpFunction) => {\n        _cleanUpFunction();\n      });\n    };\n  }, [\n    Object.values(_destinations).toString(),\n    Object.values(headers).toString()\n  ]);\n}\n\nexport default useSubscription;\n","import { useContext } from 'react';\nimport StompContext from '../context/StompContext';\nimport { StompSessionProviderContext } from '../interfaces/StompSessionProviderContext';\n\n/**\n * Returns the Stomp Client from @stomp/stompjs\n * This will be undefined if the client is currently not connected\n */\nfunction useStompClient() {\n  const context = useContext<StompSessionProviderContext | undefined>(\n    StompContext\n  );\n\n  if (context === undefined)\n    throw new Error(\n      'There must be a StompSessionProvider as Ancestor of all Stomp Hooks and HOCs'\n    );\n\n  return context.client;\n}\n\nexport default useStompClient;\n","import React from 'react';\nimport useStompClient from '../hooks/useStompClient';\n\nfunction withStompClient<P>(WrappedComponent: React.ComponentType<P>) {\n  return (props: P) => {\n    const stompClient = useStompClient();\n    return <WrappedComponent stompClient={stompClient} {...props} />;\n  };\n}\n\nexport default withStompClient;\n","import React, { useRef } from 'react';\nimport useSubscription from '../hooks/useSubscription';\nimport { StompHeaders } from '@stomp/stompjs';\nimport {\n  MessageReceiverInterface,\n  StompMessageReceiver\n} from '../interfaces/StompMessageReceiver';\nimport { IMessage } from '@stomp/stompjs/esm6/i-message';\n\nfunction withSubscription<P>(\n  WrappedComponent: StompMessageReceiver<P>,\n  destinations: string | string[],\n  headers: StompHeaders = {}\n) {\n  return (props: P) => {\n    const ref = useRef<MessageReceiverInterface>();\n    useSubscription(\n      destinations,\n      (message: IMessage) => {\n        if (ref.current) ref.current.onMessage(message);\n      },\n      headers\n    );\n\n    // @ts-ignore\n    return <WrappedComponent ref={ref} {...props} />;\n  };\n}\n\nexport default withSubscription;\n","import { IMessage } from '@stomp/stompjs/src/i-message';\nimport { messageCallbackType, StompHeaders } from '@stomp/stompjs';\n\nexport const subscriptions = new Map<string, Map<string, Function>>();\n\nexport function subscribeMock(\n  destination: string,\n  callback: messageCallbackType,\n  // @ts-ignore\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  headers: StompHeaders = {}\n) {\n  const subscriptionId = Math.random().toString(36).substr(2, 9);\n\n  if (!subscriptions.has(destination)) {\n    subscriptions.set(destination, new Map<string, Function>());\n  }\n\n  // @ts-ignore\n  subscriptions.get(destination).set(subscriptionId, callback);\n\n  return () => {\n    // @ts-ignore\n    subscriptions.get(destination).delete(subscriptionId);\n  };\n}\n\n/**\n * Simulates receiving a message from the server to the specified destination\n * @param destination The topic to send the message to\n * @param message The message to send\n */\nexport function mockReceiveMessage(\n  destination: string,\n  message: IMessage\n): void {\n  if (subscriptions.has(destination)) {\n    // @ts-ignore\n    subscriptions.get(destination).forEach((callback: Function) => {\n      callback(message);\n    });\n  }\n}\n\n/**\n * Gets the current subscriptions for the specified destination\n * @param destination The topic to get the subscriptions for, or undefined to get all subscriptions\n */\nexport function getMockSubscriptions(destination?: string) {\n  if (destination) {\n    return subscriptions.get(destination);\n  }\n  return subscriptions;\n}\n","import { IPublishParams } from '@stomp/stompjs';\n\nexport const messages = new Map<string, Array<IPublishParams>>();\n\n/**\n * A mock implementation of the publish function of the @stomp/stompjs client.\n * Will store the messages in a map, keyed by the destination.\n * @param params\n */\nexport function mockClientPublish(params: IPublishParams) {\n  if (!messages.has(params.destination)) {\n    messages.set(params.destination, []);\n  }\n\n  // @ts-ignore\n  messages.get(params.destination).push(params);\n}\n\n/**\n * Gets a default Mock of the @stomp/stompjs client.\n * If you require a custom client, you can use this as a base.\n */\nexport function getMockClient() {\n  return {\n    publish: mockClientPublish\n  };\n}\n\n/**\n * Gets all messages which have been sent via a mock client.\n * @param destination The destination to get messages for, or undefined to get all messages.\n */\nexport function getSentMockMessages(destination?: string) {\n  if (destination) {\n    return messages.get(destination);\n  }\n  return messages;\n}\n","import React from 'react';\nimport StompContext from '../context/StompContext';\nimport { subscribeMock } from './subscriptions';\nimport { getMockClient } from './client';\n\n/**\n * A mock StompSessionProvider.\n * Messages send via this mock implementation can be received via the getSentMockMessages method.\n * Subscriptions can be received via the getMockSubscriptions method.\n * The sendMockMessage method can be used, to simulate receiving a message from the server.\n *\n * @param props.client Optional. Can be used to provide a custom mock of the sompjs client,\n * in case you require additional properties/functions to be present. getMockClient can be used as a base.\n * @constructor\n */\nexport default function StompSessionProviderMock(props: {\n  children: React.ReactNode;\n  client?: any;\n}) {\n  return (\n    <StompContext.Provider\n      value={{\n        subscribe: subscribeMock,\n        // @ts-ignore\n        client: props.client ?? getMockClient()\n      }}\n    >\n      {props.children}\n    </StompContext.Provider>\n  );\n}\n","import { subscriptions } from './subscriptions';\nimport { messages } from './client';\n\n/**\n * Resets the state of the mock implementation, clearing all subscriptions and messages.\n */\nexport function reset() {\n  subscriptions.clear();\n  messages.clear();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}